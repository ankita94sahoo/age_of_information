# -*- coding: utf-8 -*-
"""gillbert_elliot_channel_with_delay.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CU98Tsk3foXGH2Ednt0rum-Jprez3EDF
"""

import os
import pandas as pd
import glob
import numpy as np
import datetime as dt
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt
from fbprophet import Prophet
from sklearn.metrics import mean_squared_error, mean_absolute_error
plt.style.use('fivethirtyeight') # For plots

pjme = pd.read_csv('./dataset/PJME_hourly.csv',
                   index_col=[0], parse_dates=[0]) # We set the index column and know it has dates

df = pd.read_csv("./server_client/server_files/Recieved_file.csv")

"""Setting up PJME Fresh Dataset"""

pjme.head()

"""Setting up Delayed and Dropped samples Dataset """

df.head()

df = df[df.Datetime != "Datetime"]

df.head()

df = df.reset_index(drop=True)

df.head()

df['Datetime'] = pd.to_datetime(df['Datetime'],errors='coerce')
df['PJME_MW']= df['PJME_MW'].astype(float)

df_h = df.copy()
df_m = df.copy()
df_s = df.copy()
df_ms = df.copy()

df_s.delay = df_s.delay.astype('str')
df_s.delay = df_s.delay.astype('int')
df_s.delay = df_s.delay.astype('timedelta64[s]')
df_s.head()

df_m.delay = df_m.delay.astype('timedelta64[m]')
df_m.head()

df_h.delay = df_h.delay.astype('timedelta64[h]')
df_h.head()

df_ms.delay = df_ms.delay.astype('timedelta64[ms]')
df_ms.head()

df_ms['Datetime'] = df_ms['Datetime'] + df_ms['delay']
df_ms.head()

df_s = df_s.drop(['delay'],axis=1)

df_s = df_s.set_index('Datetime')
df_s.head()

"""## Running the Model"""

df.head()

df.dtypes

df['Datetime'].dt.hour



def create_features(df, label=None):
    """
    Creates time series features from datetime index.
    """
    df = df.copy()
    df['date'] = df.index
    # df['date'] = pd.to_datetime(df['date'])
    # print(df['date'].dtypes)
    df['hour'] = df['Datetime'].dt.hour
    df['dayofweek'] = df['Datetime'].dt.dayofweek
    df['quarter'] = df['Datetime'].dt.quarter
    df['month'] = df['Datetime'].dt.month
    df['year'] = df['Datetime'].dt.year
    df['dayofyear'] = df['Datetime'].dt.dayofyear
    df['dayofmonth'] = df['Datetime'].dt.day
    df['weekofyear'] = df['Datetime'].dt.weekofyear
    
    X = df[['hour','dayofweek','quarter','month','year',
           'dayofyear','dayofmonth','weekofyear']]
    if label:
        y = df[label]
        return X, y
    return X

X, y = create_features(df_ms, label='PJME_MW')

features_and_target = pd.concat([X, y], axis=1)

# See our features and target
features_and_target.head()

"""Plotting the Features to see trends
1. Power demand has strong daily and seasonal properties.
2. Day of week also seems to show differences in peaks
"""

sns.pairplot(features_and_target.dropna(),
             hue='hour',
             x_vars=['hour','dayofweek',
                     'year','weekofyear'],
             y_vars='PJME_MW',
             height=5,
             plot_kws={'alpha':0.15, 'linewidth':0}
            )
plt.suptitle('Power Use MW by Hour, Day of Week, Year and Week of Year')
plt.show()

"""## Train/Test Split"""

#Splitting the Fresh dataset
split_date = '01-Jan-2015'
print(pjme.loc[pjme.index].dtypes)
pjme_train_fresh = pjme.loc[pjme.index <= split_date].copy()
pjme_test_fresh = pjme.loc[pjme.index > split_date].copy()

pjme.index

df_ms.head()

df_ms.dtypes

np.datetime64('2015-01-01')

df_ms = df_ms.set_index('Datetime')

df_ms

df_ms.index

#Splitting the Delayed dataset in terms of milliseconds
split_date = '01-Jan-2015'
pjme_train_delayed = df_ms.loc[df_ms.index <= split_date].copy()
pjme_test_delayed= df_ms.loc[df_ms.index > split_date].copy()

#Splitting the Delayed dataset in terms of seconds
#split_date = '01-Jan-2015'
#pjme_train_delayed = df_s.loc[df_s.index <= split_date].copy()
#pjme_test_delayed= df_s.loc[df_s.index > split_date].copy()

"""## ERROR Metrics"""

def mean_absolute_percentage_error(y_true, y_pred): 
    """Calculates MAPE given y_true and y_pred"""
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

"""## Simple Prophet Model

## Check on Delayed terms in milliseconds

Case 1: Train on Delayed and Test also on Delayed
"""

# Format data for prophet model using ds and y
pjme_train_delayed.reset_index() \
    .rename(columns={'Datetime':'ds',
                     'PJME_MW':'y'}).head()

# Setup and train model and fit
model = Prophet()
model.fit(pjme_train_delayed.reset_index() \
              .rename(columns={'Datetime':'ds',
                               'PJME_MW':'y'}))

# Predict on testing set with model (delayed Dataset)
pjme_test_fcst = model.predict(df=pjme_test_delayed.reset_index() \
                                   .rename(columns={'Datetime':'ds'}))

# Plot the forecast
f, ax = plt.subplots(1)
f.set_figheight(5)
f.set_figwidth(15)
fig = model.plot(pjme_test_fcst,
                 ax=ax)
plt.show()

mean_squared_error(y_true=pjme_test_delayed['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

mean_absolute_error(y_true=pjme_test_delayed['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

mean_absolute_percentage_error(y_true=pjme_test_delayed['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

"""Case 2: Training on Delayed and Dropped Dataset and test on Fresh"""

# Format data for prophet model using ds and y
pjme_train_delayed.reset_index() \
    .rename(columns={'Datetime':'ds',
                     'PJME_MW':'y'}).head()

# Setup and train model and fit
model = Prophet()
model.fit(pjme_train_delayed.reset_index() \
              .rename(columns={'Datetime':'ds',
                               'PJME_MW':'y'}))

# Predict on testing set with model (Fresh Dataset)
pjme_test_fcst = model.predict(df=pjme_test_fresh.reset_index() \
                                   .rename(columns={'Datetime':'ds'}))

# Plot the forecast
f, ax = plt.subplots(1)
f.set_figheight(5)
f.set_figwidth(15)
fig = model.plot(pjme_test_fcst,
                 ax=ax)
plt.show()

mean_squared_error(y_true=pjme_test_fresh['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

mean_absolute_error(y_true=pjme_test_fresh['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

mean_absolute_percentage_error(y_true=pjme_test_fresh['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

"""Case 3 : Train on Fresh , Test on delayed"""

# Format data for prophet model using ds and y
pjme_train_fresh.reset_index() \
    .rename(columns={'Datetime':'ds',
                     'PJME_MW':'y'}).head()

model = Prophet()
model.fit(pjme_train_fresh.reset_index() \
              .rename(columns={'Datetime':'ds',
                               'PJME_MW':'y'}))

# Predict on testing set with model (delayed Dataset)
pjme_test_fcst = model.predict(df=pjme_test_delayed.reset_index() \
                                   .rename(columns={'Datetime':'ds'}))

# Plot the forecast
f, ax = plt.subplots(1)
f.set_figheight(5)
f.set_figwidth(15)
fig = model.plot(pjme_test_fcst,
                 ax=ax)
plt.show()

mean_squared_error(y_true=pjme_test_delayed['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

mean_absolute_error(y_true=pjme_test_delayed['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])

mean_absolute_percentage_error(y_true=pjme_test_delayed['PJME_MW'],
                   y_pred=pjme_test_fcst['yhat'])